<html><head><title>PCAP::Bam</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.28,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.016003 at Mon Mar  3 23:33:40 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Object_Methods'>Object Methods</a>
    <li class='indexItem indexItem2'><a href='#Non_Object_Methods'>Non Object Methods</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PCAP::Bam - Methods that process BAM files</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Object_Methods"
>Object Methods</a></h2>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre>  my $bam = PCAP::Bam-&#62;new($bam_file);</pre>

<p>Generate a BAM object to allow access to object based functions. Primarily added to allow efficient access to header information without re-parsing once populated.</p>

<dt><a name="read_group_info"
>read_group_info</a></dt>

<dd>
<pre>  my $rg_data = $bam-&#62;read_group_info($required_tags);</pre>

<p>Returns an arrayref (one entry per readgroup) of hashes where the keys are the RG tags found in the @RG header line. Providing an arrayref of required_tags causes an error to be raised if any are not found:</p>

<pre>  my $rg_data = $bam-&#62;read_group_info([qw(CN LB SN)]);</pre>

<p>Resulting data structure:</p>

<pre>  [ { CN =&#62; &#39;SI&#39;,
      LB =&#62; &#39;LIBRARY_ID&#39;,
      SM =&#62; &#39;Sample_name},
    { CN =&#62; ...
    },
    ...];</pre>

<dt><a name="single_rg_value"
>single_rg_value</a></dt>

<dd>
<pre>  my $sample_name = $bam-&#62;single_rg_value(&#39;SM&#39;);</pre>

<p>Gets the value of a single RG tag. Errors if multiple readgroups detected.</p>

<dt><a name="check_for_tags"
>check_for_tags</a></dt>

<dd>
<pre>  $bam-&#62;check_for_tags([list of required tags]);</pre>

<p>Check that all readgroups in this BAM have the specified tags. Errors if any are not detected.</p>

<dt><a name="check_paired"
>check_paired</a></dt>

<dd>
<pre>  $bam-&#62;check_paired;</pre>

<p>Will error if BAM file doesn&#39;t contain paired reads.</p>

<dt><a name="comments"
>comments</a></dt>

<dd>
<pre>  my @comments = @{$bam-&#62;comments};</pre>

<p>Returns an array ref of the value of each comment line. &#39;@CO\t&#39; is pre-stripped.</p>

<dt><a name="sam_header"
>sam_header</a></dt>

<dd>
<pre>  my @header_lines = @{$bam-&#62;sam_header};</pre>

<p>Returns array ref of all header lines. One entry perl line.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Non_Object_Methods"
>Non Object Methods</a></h2>

<dl>
<dt><a name="bam_to_grouped_bam"
>bam_to_grouped_bam</a></dt>

<dd>
<pre>  PCAP::Bam::bam_to_grouped_bam($index, $options);</pre>

<p>Convert a BAM for a single readgroup to a readname grouped BAM.</p>

<pre>  index   - Which element of the &#39;bams&#39; array reference found in options should be processed
              NOTE: index is origin 1

  options - Hashref, requires the following entries:

          -tmp  : working/output directory depending on application
          -bams : array reference to a B&#60;sorted&#62; list of BAM files (to allow resume function)</pre>

<p>On successful completion of a run a file is created in tmp/progress/bamcollate.$index. If the program is re-run without clearing of this progress folder the execution of the command is skipped.</p>

<dt><a name="merge_and_mark_dup"
>merge_and_mark_dup</a></dt>

<dd>
<pre>  PCAP::Bam::merge_and_mark_dup($options);</pre>

<p>Takes a list of sorted BAM files, marks duplicates and produces single output BAM in one pass.</p>

<pre>  options - Hashref, requires the following entries:

          -tmp      : working/output directory depending on application
          -bams     : array reference to a B&#60;sorted&#62; list of BAM files (for consistent results)
          -outdir   : output files written to this folder
          -sample   : prefix of output file
          -threads  : Total threads available to process

  returns - path_to_marked_bam</pre>

<p>Resulting data is of the form:</p>

<pre>  $outdir/$sample.bam
  $outdir/$sample.bam.bai
  $outdir/$sample.bam.md5
  $outdir/$sample.met</pre>

<dt><a name="sample_name"
>sample_name</a></dt>

<dd>
<p>Takes BAM or Bio::DB::Sam object as input and returns the sample name found in the header.</p>

<p>The SAM object is also returned should it be useful for other calls</p>

<dt><a name="rg_line_for_output"
>rg_line_for_output</a></dt>

<dd>
<p>Takes BAM or Bio::DB::Sam object as input and returns the string representation for the RG line. Intended for use when adding RG to BWA MEM output and is only useful in single RG BAMs</p>

<p>The SAM object is also returned should it be useful for other calls</p>

<dt><a name="sam_ob"
>sam_ob</a></dt>

<dd>
<pre>  my $sam_ob = sam_ob(&#39;file.bam&#39;);</pre>

<p>Generate a Bio::DB::Sam object from the provided BAM file.</p>
</dd>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
